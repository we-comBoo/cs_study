## 키(Key)

### 키

: 데이터베이스에서 조건에 따른 검색이나 정렬시 다른 튜플들과 구별할 수 있는 기준이 되는 속성

### 키 특성

- 유일성: 식별자에 의해 모든 튜플들을 유일하게 구분하는 성질

- 최소성: 최소한의 속성으로 식별자를 구성하는 성질



#### 후보 키(Candidate Key)

: 릴레이션에서 각 튜플을 구별하는 데 기준이 되는 속성 또는 속성 집합

- 유일성과 최소성을 만족



#### 기본 키(Primary Key)

: 릴레이션의 각 튜플들을 고유하게 식별하는 속성

- null 값이나 중복 값을 가질 수 없음

- 후보 키로 자연 키와 인조 키가 있을 경우 인조 키를 선택

- 자연 키: 비즈니스 모델에서 자연스럽게 나오는 속성

- 인조 키: 키 역할을 하기 위해 인조적으로 만든 속성 e.g. UUID

- 자연 키는 변경될 가능성이 있으나 인조 키는 변경되지 않으므로 자연 키와 인조 키 중 인조 키를 기본 키로 선택



#### 대체 키(Alternate Key)

: 후보 키 중 기본 키를 제외한 나머지 키



#### 슈퍼 키(Super Key)

: 유일성은 만족하지만 최소성은 만족하지 못하는 키



#### 외래 키(Foreign Key)

: 다른 릴레이션의 기본 키를 그대로 참조하는 속성

- 테이블 간의 참조 데이터 무결성을 위한 제약 조건

- 외래 키를 통해 테이블 간의 관계 표현 가능



#### 기타

- 복합 키(Composite Key): 두 개 이상의 속성으로 구성되는 후보 키

- 유일 키(고유 키, Unique Key): 중복 값 허용x, null 값 허용o





## 인덱스(Index)

### 인덱스

: 데이터베이스 테이블에서의 검색 속도 향상을 위한 자료구조

- 데이터와 데이터의 위치를 포함하는 자료구조 생성//테이블의 컬럼 색인화

- 테이블 검색 시 테이블 전체를 스캔하지 않아도 되므로 검색 속도 향상



### 인덱스 사용의 단점

- 인덱스 관리에 추가적인 메모리가 사용됨

- 인덱스를 생성하면 DML 쿼리문을 실행할 때 데이터 갱신에 따른 추가적인 처리과정이 발생함

- 데이터 형식에 따라 인덱스 생성의 효율성 차이 존재



### 인덱스를 생성해야 하는 경우

- FK 사용 컬럼

- JOIN에 자주 사용되는 컬럼



### 인덱스를 생성하지 말아야 하는 경우

- DML(INSERT, UPDATE, DELETE)가 자주 일어나는 경우

- 데이터의 중복도가 높은 컬럼(성별 등)



### 인덱스 자료구조

#### Primary index vs Secondary index

- Single-Level Ordered Indexes

- 엔트리는 탐색 키 값의 오름차순으로 정렬되어 있음

- Primary index | sparse index

: 탐색 키가 테이블의 기본 키(PK)인 인덱스. 탐색 키 값에 따라 정렬된 데이터 파일에 대한 정의

+클러스터드 인덱스: PK값이 비슷한 레코드끼리 묶어서 저장하는 것. PK 값에 의해 레코드의 저장 위치가 결정되며, PK값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 함. 클러스터드 인덱스는 테이블 당 한 개만 생성 가능(PK에 대해서만 적용되기 때문).

- Secondary index | dense index

: 보조 인덱스. 레코드의 위치를 알려주는 역할



#### B+- tree vs Hash table

- Multi-Level Indexes

- 인덱스 자체가 큰 경우, 인덱스 탐색 시간 증가

- Single-Level Ordered Indexes를 하나의 파일로 생각해서 이에 대해 다시 인덱스 정의

- B+- tree 인덱스 알고리즘

: 컬럼 값을 변형하지 않고 그대로 인덱싱

-B-tree는 자식 노드가 2개 이상인 트리. 루트 노드에서 단말 노드까지의 거리가 모두 동일

-B+tree는 B-tree를 확장 및 개선한 트리로, 인덱스 역할만 하는 비단말 노드가 분리되어 있음.

- Hash Table 인덱스 알고리즘

: 컬럼 값으로 해시 값을 계산해서 인덱싱(해시 함수 사용). 매우 빠른 검색을 지원하지만 값을 변형해서 인덱싱하므로, 값의 일부만으로 검색하고자 할 땐 사용 불가. 

+인덱스 생성에 B-tree를 사용하는 이유: Hash table은 B-tree 보다 효율적인 시간복잡도를 가지고 있지만(O(1))  Hash table은 등호(=)연산에 특화되어 있어서 등호가 아닌 부등호(<,>)연산의 경우 문제가 발생할 수 있으므로 적합하지 않음 





## 정규화

### 정규화

: 관계형 데이터베이스의 설계에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 데이터를 구조화하는 과정

-데이터의 중복성을 제거하여 데이터베이스 무결성 유지 및 저장 용량의 효율적 관리가 가능해짐 



### 이상 현상

: 릴레이션 조작 시 데이터의 중복성으로 인해 발생하는 현상

- 삽입 이상: 정보 저장 시 해당 정보의 불필요한 세부 정보까지 입력해야 함

- 삭제 이상: 정보 삭제 시 원치 않는 다른 정보까지 같이 삭제됨

- 갱신 이상: 중복 데이터 중 특정 부분만 수정되어 중복값에서 모순이 발생함



#### 제 1 정규형(1NF)

: 릴레이션의 모든 속성의 도메인이 원자값으로만 구성됨.

- 1NF만 만족하면 부분 함수 종속성으로 인해 삽입, 삭제, 갱신 이상이 모두 나타날 수 있다



#### 제 2 정규형(2NF)

: 제 1 정규형을 만족하고, 기본 키가 아닌 모든 속성은 기본 키에 완전 함수 종속 관계를 가짐

- 부분 함수 종속을 제거하여 2NF를 만족할 수 있다

- 완전 함수 종속: 릴레이션에서 X->Y 관계가 있을 때 Y는 X의 전체 속성에 대해 종속, X의 부분 집합 속성에는 종속하지 않는다.

- 2NF을 만족해도 이행적 함수 종속으로 인해 삽입, 삭제, 갱신 이상이 나타날 수 있다. 



#### 제 3 정규형(3NF)

 : 제 2 정규형을 만족하고, 기본 키가 아닌 모든 속성이 기본 키에 이행적으로 종속되지 않음

- 이행적 함수 종속: 릴레이션에서 X->Y, Y->Z 종속 관계가 있을 때, X->Z가 성립

- 3NF를 만족해도 후보 키를 여러 개 가지고 있는 릴레이션에서는 이상 현상 발생 가능



#### BCNF; Boyce-Codd- Normal Form

: strong 3NF, 모든 결정자가 후보 키 집합에 속하는 정규형



### 정규화 단점

- 데이터 중복을 제거하고 릴레이션을 분해함으로써 릴레이션 간의 연산이 늘어남(JOIN)

- 따라서 데이터 처리 속도가 빨라질 수도 있지만 느려질 수도 있음 

- 반정규화: 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행





## 트랜잭션

### 트랜잭션

: 데이터베이스에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위

- 하나의 논리적 작업 단위를 구성하는 연산들의 집합

- 데이터의 정합성을 보장하기 위한 기능



### 트랜잭션의 특성(ACID)

- 원자성(Atomicity): 트랜잭션을 구성하는 연산 전체가 성공하거나 취소되어야 하는 성질

- 일관성(Consistency): 시스템의 고정요소는 트랜잭션 수행 전과 수행 완료 후의 상태가 같아야 하는 성질

- 격리성, 고립성(Isolation): 동시에 실행되는 둘 이상의 트랜잭션들은 서로 영향을 미치지 않아야 한다는 성질. 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들거나 다른 트랜잭션에서 수행 결과를 참조할 수 없음

- 영속성(Durability): 완료된 트랜잭션의 결과는 데이터베이스에 영속적으로 반영되어야 하는 성질



### 트랜잭션의 상태 변화

- Active: 트랜잭션이 실행 중인 상태

- Partially Committed: 마지막 쿼리가 실행된 후의 상태. commit 요청이 들어온 상태.

- Failed: 트랜잭션이 더 이상 정상적으로 진행될 수 없는 상태. 트랜잭션 실패 상태

- Committed: 트랜잭션이 성공적으로 완료된 상태

- Aborted: 트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작 전의 상태로 돌아간 상태



### 트랜잭션 제어

- TCL

- COMMIT: 트랜잭션 작업 내용을 DB에 영구적으로 저장. 트랜잭션 확정 및 종료

- ROLLBACK: 트랜잭션 작업을 모두 취소하고 트랜잭션 실행 이전 상태로 되돌림. 트랜잭션 종료

- CHECKPOINT: 롤백을 위한 시점을 지정 



### 병행 제어(동시성 제어, Concurrency control)

: 다수의 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 기법



#### 병행 제어의 필요성

//병행 제어 미보장 시 문제점

- Lost Update(갱신 손실): 트랜잭션들이 동일한 데이터에 동시에 갱신할 때 발생. 먼저 실행된 트랜잭션의 결과를 나중에 실행된 트랜잭션이 덮어쓸 때 발생하는 오류 

- Dirty Read: 트랜잭션의 중간 수행 결과(커밋되지 않은 데이터)를 다른트랜잭션이 참조하여 발생하는 오류

- Inconsistency(모순성): 여러 트랜잭션이 동시에 수행되어 끼어들기에 의해 데이터베이스의 일관성이 유지되지 못하는 오류

- Cascading Rollback(연쇄복귀): 여러 트랜잭션이 동시에 실행되고 있을 때(데이터 공유), 특정 트랜잭션이 처리를 취소할 경우(Rollback), 나머지 트랜잭션도 Rollback되는 오류. 이미 실행 완료된 트랜잭션이 있으면 트랜잭션의 지속성에 따라 Rollback 불가능(Unrecoverability, 회복불가능성)



#### 로킹(Locking)

- 병행 제어 기법 중 하나 

- 하나의 트랜잭션을 실행하는 동안 특정 데이터 항목에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 상호배제 기능을 제공. 순서대로 한 시점에는 하나의 트랜잭션만 데이터베이스의 특정 데이터 항목을(데이터베이스 커넥션을) 조작할 수 있게 함.

- 로킹 단위: 한번에 로킹할 수 있는 객체의 크기

- 데이터베이스, 파일, 레코드 등이 로킹 단위가 될 수 있음

- 로킹 단위가 작아지면 데이터베이스 공유도 증가(동시성 수준 증가)

- 로킹 단위가 작아지면 로킹 오버헤드 증가



#### 트랜잭션 격리 수준(Isolation Level) 



#### 교착상태

: 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 row)의 Lock을 획득한 채로 다른 트랜잭션이 갖고 있는 Lock 자원을 요청하면 아무리 기다려원 요청 자원을 획득할 수 없는 상태. 







## SQL vs NoSQL
