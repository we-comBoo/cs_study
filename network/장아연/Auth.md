## 인증 : Authentication
1. 사용자의 신원을 검증하는 행위
2. 인증 프로세스 (비밍번호, 일회용핀 등)을 구성하여 성공적으로 확인되어야만 시스템에 엑세스 가능

## 인가 : Authorization
1. 인증된 사용자에 대한 자원 접근 권한 확인

## 흐름
### 1. 인증하기 - Request Header 활용
**과정**

1. 사용자 인증 정보를 request header에 담아 인증을 요청함

**단점**

* request header만 사용하면 사용자가 매번 인증해야함


### 2. 인증 유지하기 - Browser 활용 - 쿠키 & 웹스토리지
**과정**

1. 사용자가 인증이 필요한 요청함
2. 쿠키/웹스토리지에 저장된 사용자 인증 정보를 활용해 서버에 전달함
3. 서버는 이를 기반으로 클라이언트를 식별함 

**단점**
* 보안에 취약함 (요청 시 쿠키 값을 그대로 보내어 유출 및 조작 가능성 존재)
* 용량 제한 존재
* 브라우저마다 쿠키 지원 형태가 다름
* 쿠키 사이즈에 따라 네트워크 부하 발생 가능

### 3. 안정하게 인증하기 - Server를 활용한 Session
**과정**
1. 클라이언트가 로그인 요청함
2. 서버는 세션 저장소를 활용해 사용자 인증 정보를 저장하고 클라이언트 식별자 `JSESSIONID`를 클라이언트에게 전달함
3. 이후 클라이언트는 함께 `JSESSIONID`와 함께 요청을 보냄
4. 서버는 `JSESSION`의 유효성을 판별하며 클라이언트를 식별함

**장점**
* 요청이 노출되어서 세션 ID 자체는 유의미한 개인 정보가 아님
* 서버가 클라이언트의 웹 브라우저에 의존하지 않음

**단점**
* 해커가 세션 ID를 탈취해 해당 클라이언트로 위장 가능
* 서버에 세션ID가 저장되는데 사용자나 요청이 많아지는 경우 부하 발생 가능
### 4. 효율적으로 인증하기 - 흐름에 상태를 담는 Token
JSON Web Token : 인증에 필요한 정보들을 암호화 시킨 토큰
**JWT 구성**

1. Header
2. Payload
3. Signature

**과정**
1. 클라이언트가 로그인 요청함
2. 서버가 검증 후, 클라이언트 고유 ID 등의 정보를 Payload에 담음
3. 비밀키를 사용해 JWT (Access Token)을 발급함
4. 클라이언트는 JWT 토큰을 저장해두고, 서버에 요청시마다 토큰을 request header의 Authorization에 포함에 전달함
5. 서버는 토큰의 Signature을 비밀키로 복호화해 위변조 여부 및 유효 기간 등을 확인함
6. 유효한 토큰이라면 요청에 응답함

**장점**
* 인증 정보 저장을 위한 별도의 저장소 필요 X (I/O 과정 불필요함)
* JWT 자체가 토큰에 대한 기본적인 정보, 전달할 정보, 검증되었음을 증명하는 성명 등을 자체적으로 지니고 있음
* 확장성이 우수함

**단점**
* 특정 사용자의 접속을 강제로 만료하기 어려움
* JWT 토큰의 길이가 길어 인증 요청이 많은 경우 네트워크 부하 발생 가능

**단점 보완을 위한 토큰 전략**
1. 짧은 만료 기한 설정
2. Sliding Session
* 서비스를 지속적으로 이용하는 클라이언트에 대해 자동으로 토큰 만료 기한 연장함
3. Refresh token
* 로그인 시 Access Token과 Refresh Token 발급함
* Access Token이 만료되었을때, Refresh Token을 이용해 Access Token의 재발급 요청함
* 서버는 DB에 저장된 Refresh Token과 비교해 해당 토큰이 유효하면 Access Token을 발급함 (만약 Refresh Token도 만료된 경우 사용자에게 로그인을 요청함)
* 서버가 강제로 Refresh Token을 만료해 특정 사용자 접속을 막을 수 있음
* Refresh Token 검증을 위한 DB와 I/O 작업 필요함
### 5. 다른 채널을 통해 인증하기 - OAuth

